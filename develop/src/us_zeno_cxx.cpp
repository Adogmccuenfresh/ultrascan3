#define USE_RAND_RNG
#define USE_SPHERE_CENTERS_MODEL 
#define USE_NANOFLANN_SORT_SCM
#if __cplusplus >= 201103L
#include <future>
#include <chrono>
#include "../include/us_hydrodyn_zeno.h"

#undef R
#include "qprogressbar.h"
extern QProgressBar *zeno_progress;
extern bool *zeno_stop_flag;

#include <fstream>
class zeno_fout {
public:
   zeno_fout( const char * fname ) { ofs.open( fname ); };
   ~zeno_fout() { if ( ofs.is_open() ) { ofs.close(); } };
   std::ofstream ofs;
};
extern zeno_fout* zeno_cxx_fout;
#include "../include/us_zeno_cxx.h"
zeno_fout *zeno_cxx_fout;
// *** START *** lex.cc ***
// Generated by Flexc++ V1.08.00 on Tue, 20 Oct 2015 17:44:37 -0400

#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>

// note: this program uses cout and/or cerr and this should be replaced

static std::basic_ostream<char>& operator<<(std::basic_ostream<char>& os, const QString& str) { 
   return os << qPrintable(str);
}

// $insert class_ih
// inlined #include "Scanner.ih"


    // s_ranges__: use (unsigned) characters as index to obtain
    //           that character's range-number.
    //           The range for EOF is defined in a constant in the
    //           class header file
size_t const ScannerBase::s_ranges__[] =
{
     0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
     4, 4, 4, 4, 4, 4, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 8, 9,10,11,12,13,13,
    13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,
    15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,17,18,18,
    18,19,20,20,21,22,22,22,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,32,32,
    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
    32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
    32,32,32,32,32,33,
};

    // s_dfa__ contains the rows of *all* DFAs ordered by start state.
    // The enum class StartCondition__ is defined in the baseclass header
    // INITIAL is always 0.
    // Each entry defines the row to transit to if the column's
    // character range was sensed. Row numbers are relative to the
    // used DFA and d_dfaBase__ is set to the first row of the subset to use.
    // The row's final two values are begin and end indices in
    // s_rfc__[] (rule, flags and count), defining the state's rule details
int const ScannerBase::s_dfa__[][37] =
{
    // INITIAL
    {-1, 1, 1, 1,-1, 1,-1,-1, 2,-1, 2,-1, 3, 4,-1, 5,-1, 6, 5, 5,
          5, 7, 5, 5, 5, 5, 5, 5, 5, 8, 5, 5,-1,-1,-1,   0, 0},  // 0
    {-1, 1, 1, 1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,   0, 1},  // 1
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,   1, 1},  // 2
    {-1,-1,-1,-1,-1,-1,-1,10,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,   1, 1},  // 3
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1, 4,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,   1, 2},  // 4
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,   2, 3},  // 5
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5,13, 5,-1,-1,-1,   3, 4},  // 6
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5,14,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,   4, 5},  // 7
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5,15, 5, 5, 5,16, 5,-1,-1,-1,   5, 6},  // 8
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1, 9,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,   6, 7},  // 9
    {-1,10,-1,10,10,10,10,17,10,10,10,10,10,10,10,10,10,10,10,10,
         10,10,10,10,10,10,10,10,10,10,10,10,10,10,-1,   7, 7},  // 10
    {-1,11,18,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
         11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,   7, 7},  // 11
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,   7, 7},  // 12
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5,20, 5, 5, 5, 5, 5, 5,-1,-1,-1,   7, 8},  // 13
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5,21, 5,-1,-1,-1,   8, 9},  // 14
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5,22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,   9,10},  // 15
    {-1,23,24,23,23,23,23,23,23,23,23,23,23,16,23,16,23,16,16,16,
         16,16,16,16,16,16,16,16,16,16,16,16,23,-1,-1,  10,11},  // 16
    {-1,10,-1,10,10,10,10,17,10,10,10,10,25,10,10,10,10,10,10,10,
         10,10,10,10,10,10,10,10,10,10,10,10,10,10,-1,  11,11},  // 17
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  11,12},  // 18
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  12,13},  // 19
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5,26, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  13,14},  // 20
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1,27, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  14,15},  // 21
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5,28,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  15,16},  // 22
    {-1,23,24,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
         23,23,23,23,23,23,23,23,23,23,23,23,23,-1,-1,  16,16},  // 23
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  16,17},  // 24
    {-1,10,-1,10,10,10,10,17,10,10,10,10,10,10,10,10,10,10,10,10,
         10,10,10,10,10,10,10,10,10,10,10,10,10,10,-1,  17,18},  // 25
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  18,19},  // 26
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5,29, 5,-1,-1,-1,  19,20},  // 27
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5,30, 5, 5, 5,-1,-1,-1,  20,21},  // 28
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5,26, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  21,22},  // 29
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5,31,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  22,23},  // 30
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1, 5,-1, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,-1,-1,-1,  23,24},  // 31
};

    // The first value is the rule index
    // The second value is the FLAG: see the scannerbase.h file
    // 1: Final     4: Count        11: Final/BOL,Inc     
    // 2: Inc.      5: Final,Count  13: Final/BOL,Count
    // 3: Final,Inc 9: Final/BOL    
    // The third value is the LOP count value (valid for Count flags)
size_t const ScannerBase::s_rfc__[][3] =
{
//     R  F  C
     { 2, 1, 0},  // 0
     { 4, 1, 0},  // 1
     { 8, 1, 0},  // 2
     { 8, 1, 0},  // 3
     { 8, 1, 0},  // 4
     { 6, 1, 0},  // 5
     { 5, 1, 0},  // 6
     { 8, 1, 0},  // 7
     { 8, 1, 0},  // 8
     { 8, 1, 0},  // 9
     { 8, 1, 0},  // 10
     { 1, 1, 0},  // 11
     { 5, 1, 0},  // 12
     { 8, 1, 0},  // 13
     { 8, 1, 0},  // 14
     { 8, 1, 0},  // 15
     { 3, 1, 0},  // 16
     { 0, 1, 0},  // 17
     { 7, 1, 0},  // 18
     { 8, 1, 0},  // 19
     { 8, 1, 0},  // 20
     { 8, 1, 0},  // 21
     { 8, 1, 0},  // 22
     { 6, 1, 0},  // 23
};

int const (*ScannerBase::s_dfaBase__[])[37] =
{
    s_dfa__ + 0,
};

size_t ScannerBase::s_istreamNr = 0;

// $insert inputImplementation
ScannerBase::Input::Input()
:
    d_in(0),
    d_lineNr(1)
{}

ScannerBase::Input::Input(std::istream *iStream, size_t lineNr)
:
    d_in(iStream),
    d_lineNr(lineNr)
{}

size_t ScannerBase::Input::get()
{
    switch (size_t ch = next())         // get the next input char
    {
        case '\n':
            ++d_lineNr;
        // FALLING THROUGH

        default:
        return ch;
    }
}

size_t ScannerBase::Input::next()
{
    size_t ch;

    if (d_deque.empty())                    // deque empty: next char fm d_in
    {
        if (d_in == 0)
            return AT_EOF;
        ch = d_in->get();
        return *d_in ? ch : static_cast<size_t>(AT_EOF);
    }

    ch = d_deque.front();
    d_deque.pop_front();

    return ch;
}

void ScannerBase::Input::reRead(size_t ch)
{
    if (ch < 0x100)
    {
        if (ch == '\n')
            --d_lineNr;
        d_deque.push_front(ch);
    }
}

void ScannerBase::Input::reRead(std::string const &str, size_t fm)
{
    for (size_t idx = str.size(); idx-- > fm; )
        reRead(str[idx]);
}

ScannerBase::ScannerBase(std::istream &in, std::ostream &out)
:
    d_filename("-"),
    d_startCondition(StartCondition__::INITIAL),
    d_state(0),
    d_out(new std::ostream(out.rdbuf())),
    d_sawEOF(false),
    d_atBOL(true),
    d_tailCount(9, std::numeric_limits<size_t>::max()),
// $insert interactiveInit
    d_in(0),
    d_input(new std::istream(in.rdbuf())),
    d_dfaBase__(s_dfa__)
{}

void ScannerBase::switchStream__(std::istream &in, size_t lineNr)
{
    d_input.close();
    d_state = 0;
    d_input = Input(new std::istream(in.rdbuf()), lineNr);
    d_sawEOF = false;
    d_atBOL = true;
}


ScannerBase::ScannerBase(std::string const &infilename, std::string const &outfilename)
:
    d_filename(infilename),
    d_startCondition(StartCondition__::INITIAL),
    d_state(0),
    d_out(outfilename == "-"    ? new std::ostream(zeno_cxx_fout->ofs.rdbuf()) :
          outfilename == ""     ? new std::ostream(std::cerr.rdbuf()) :
                                  new std::ofstream(outfilename)),
    d_sawEOF(false),
    d_atBOL(true),
    d_tailCount(9, std::numeric_limits<size_t>::max()),
    d_input(new std::ifstream(infilename)),
    d_dfaBase__(s_dfa__)
{}

void ScannerBase::switchStreams(std::istream &in, std::ostream &out)
{
    switchStream__(in, 1);
    switchOstream(out);
}


void ScannerBase::switchOstream(std::ostream &out)
{
    *d_out << std::flush;
    d_out.reset(new std::ostream(out.rdbuf()));
}

// $insert debugFunctions
void ScannerBase::setDebug(bool onOff)
{}

bool ScannerBase::debug() const
{
    return false;
}

void ScannerBase::redo(size_t nChars)
{
    size_t from = nChars >= length() ? 0 : length() - nChars;
    d_input.reRead(d_matched, from);
    d_matched.resize(from);
}

void ScannerBase::switchOstream(std::string const &outfilename)
{
    *d_out << std::flush;
    d_out.reset(
            outfilename == "-"    ? new std::ostream(zeno_cxx_fout->ofs.rdbuf()) :
            outfilename == ""     ? new std::ostream(std::cerr.rdbuf()) :
                                    new std::ofstream(outfilename));
}


void ScannerBase::switchIstream(std::string const &infilename)
{
    d_input.close();
    d_filename = infilename;
    d_input = Input(new std::ifstream(infilename));
    d_sawEOF = false;
    d_atBOL = true;
}

void ScannerBase::switchStreams(std::string const &infilename,
                           std::string const &outfilename)
{
    switchOstream(outfilename);
    switchIstream(infilename);
}

void ScannerBase::pushStream(std::istream  &istr)
{
    std::istream *streamPtr = new std::istream(istr.rdbuf());
    p_pushStream("(istream)", streamPtr);
}

void ScannerBase::pushStream(std::string const &name)
{
    std::istream *streamPtr = new std::ifstream(name);
    if (!*streamPtr)
    {
        delete streamPtr;
        throw std::runtime_error("Cannot read " + name);
    }
    p_pushStream(name, streamPtr);
}


void ScannerBase::p_pushStream(std::string const &name, std::istream *streamPtr)
{
    if (d_streamStack.size() == s_maxSizeofStreamStack__)
    {
        delete streamPtr;
        throw std::length_error("Max stream stack size exceeded");
    }

    d_streamStack.push_back(StreamStruct{d_filename, d_input});
    d_filename = name;
    d_input = Input(streamPtr);
    d_sawEOF = false;
    d_atBOL = true;
}


bool ScannerBase::popStream()
{
    d_input.close();

    if (d_streamStack.empty())
        return false;

    StreamStruct &top = d_streamStack.back();

    d_input =   top.pushedInput;
    d_filename = top.pushedName;
    d_streamStack.pop_back();
    d_sawEOF = false;

    return true;
}

ScannerBase::ActionType__ ScannerBase::actionType__(size_t range)
{
    d_nextState = d_dfaBase__[d_state][range];

    if (d_nextState != -1)                  // transition is possible
        return ActionType__::CONTINUE;

    if (atFinalState())                     // FINAL state reached
        return ActionType__::MATCH;

    if (d_matched.size())
        return ActionType__::ECHO_FIRST;    // no match, echo the 1st char

    return range != s_rangeOfEOF__ ? 
                ActionType__::ECHO_CH 
            : 
                ActionType__::RETURN;
}

void ScannerBase::accept(size_t nChars)          // old name: less
{
    if (nChars < d_matched.size())
    {
        d_input.reRead(d_matched, nChars);
        d_matched.resize(nChars);
    }
}

  // The size of d_matched is determined:
  //    The current state is a known final state (as determined by 
  // inspectRFCs__(), just prior to calling matched__). 
  //    The contents of d_matched are reduced to d_final's size or (if set)
  // to the LOP-rule's tail size.
void ScannerBase::determineMatchedSize(FinData const &final)
{
    size_t length = final.matchLen;
    if (final.tailCount != std::numeric_limits<size_t>::max())
        length -= final.tailCount;

    d_input.reRead(d_matched, length);      // reread the tail section
    d_matched.resize(length);               // return what's left
}

  // At this point a rule has been matched.  The next character is not part of
  // the matched rule and is sent back to the input.  The final match length
  // is determined, the index of the matched rule is determined, and then
  // d_atBOL is updated. Finally the rule index is returned.
size_t ScannerBase::matched__(size_t ch)
{
    d_input.reRead(ch);

    if (!d_atBOL)
        d_final.atBOL.rule = std::numeric_limits<size_t>::max();

    FinData &final = d_final.atBOL.rule == std::numeric_limits<size_t>::max() ? 
                            d_final.notAtBOL
                        :
                            d_final.atBOL;

    determineMatchedSize(final);

    d_atBOL = *d_matched.rbegin() == '\n';


    return final.rule;
}

size_t ScannerBase::getRange__(int ch)       // using int to prevent casts
{
    if (ch != AT_EOF)
        d_sawEOF = false;

// $insert caseCheck
    ch = tolower(ch);

    return ch == AT_EOF ? static_cast<size_t>(s_rangeOfEOF__) : s_ranges__[ch];
}

  // At this point d_nextState contains the next state and continuation is
  // possible. The just read char. is appended to d_match, and LOP counts
  // are updated.
void ScannerBase::continue__(int ch)
{
    d_state = d_nextState;

    if (ch != AT_EOF)
        d_matched += ch;
}

void ScannerBase::echoCh__(size_t ch)
{
    *d_out << static_cast<char>(ch);
    d_atBOL = ch == '\n';
}


   // At this point there is no continuation. The last character is
   // pushed back into the input stream as well as all but the first char. in
   // the buffer. The first char. in the buffer is echoed to stderr. 
   // If there isn't any 1st char yet then the current char doesn't fit any
   // rules and that char is then echoed
void ScannerBase::echoFirst__(size_t ch)
{
    d_input.reRead(ch);
    d_input.reRead(d_matched, 1);
    echoCh__(d_matched[0]);
}

    // Inspect all s_rfc__ elements associated with the current state
    //  If the s_rfc__ element has its COUNT flag set then set the 
    // d_tailCount[rule] value to the element's tailCount value, if it has its 
    // INCREMENT flag set then increment d_tailCount[rule]
    //  If neither was set set the d_tailCount[rule] to numeric_limits<size_t>::max()
    // 
    // If the s_rfc__ element has its FINAL flag set then store the rule number
    // in d_final.second. If it has its FINAL + BOL flags set then store the
    // rule number in d_final.first
void ScannerBase::inspectRFCs__()
{
    for 
    (
        size_t begin = d_dfaBase__[d_state][s_finacIdx__], 
                 end = d_dfaBase__[d_state][s_finacIdx__ + 1];
            begin != end;
                ++begin
    )
    {
        size_t const *rfc = s_rfc__[begin];
        size_t flag = rfc[FLAGS];
        size_t rule = rfc[RULE];

        if (flag & INCREMENT)
            ++d_tailCount[rule];
        else 
            d_tailCount[rule] = (flag & COUNT) ? rfc[ACCCOUNT] : std::numeric_limits<size_t>::max();

        if (flag & FINAL)
        {
            FinData &final = (flag & BOL) ? d_final.atBOL : d_final.notAtBOL;
            final = FinData { rule, d_matched.size(), d_tailCount[rule] };
        }
    }
}

void ScannerBase::reset__()
{
    d_final = Final { {std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max() }, 
                      {std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max() } };
    d_state = 0;
    d_return = true;

    if (!d_more)
        d_matched.clear();

    d_more = false;
}

int Scanner::executeAction__(size_t ruleIdx)
try
{
    switch (ruleIdx)
    {
        // $insert actions
        case 4:
        {
#line 9 "lexer"
            return Parser::INT;

        }
        break;
        case 5:
        {
#line 10 "lexer"
            return Parser::FLOAT;

        }
        break;
        case 6:
        {
#line 11 "lexer"
            return Parser::SPHERE;

        }
        break;
        case 7:
        {
#line 12 "lexer"
            return Parser::ATOM;

        }
        break;
        case 8:
        {
#line 13 "lexer"
            return Parser::STRING;

        }
        break;
    }
    noReturn__();
    return 0;
}
catch (Leave__ value)
{
    return static_cast<int>(value);
}

int Scanner::lex__()
{
    reset__();
    preCode();

    while (true)
    {
        size_t ch = get__();                // fetch next char
        size_t range = getRange__(ch);      // determine the range

        inspectRFCs__();                    // update d_tailCount values

        switch (actionType__(range))        // determine the action
        {
            case ActionType__::CONTINUE:
                continue__(ch);
            continue;

            case ActionType__::MATCH:
            {
                d_token__ = executeAction__(matched__(ch));
                if (return__())
                {
                    print();
                    postCode(PostEnum__::RETURN);
                    return d_token__;
                }
                break;
            }

            case ActionType__::ECHO_FIRST:
                echoFirst__(ch);
            break;

            case ActionType__::ECHO_CH:
                echoCh__(ch);
            break;

            case ActionType__::RETURN:
                if (!popStream())
                {
                     postCode(PostEnum__::END);
                     return 0;
                }
                postCode(PostEnum__::POP);
             continue;
        } // switch

        postCode(PostEnum__::WIP);

        reset__();
        preCode();
    } // while
}

void ScannerBase::print__() const
{
}



// *** END *** lex.cc ***

// *** START *** parse.cc ***
// Generated by Bisonc++ V4.05.00 on Tue, 20 Oct 2015 17:44:37 -0400

// $insert class.ih
// inlined #include "Parser.ih"

// The FIRST element of SR arrays shown below uses `d_type', defining the
// state's type, and `d_lastIdx' containing the last element's index. If
// d_lastIdx contains the REQ_TOKEN bitflag (see below) then the state needs
// a token: if in this state d_token__ is _UNDETERMINED_, nextToken() will be
// called

// The LAST element of SR arrays uses `d_token' containing the last retrieved
// token to speed up the (linear) seach.  Except for the first element of SR
// arrays, the field `d_action' is used to determine what to do next. If
// positive, it represents the next state (used with SHIFT); if zero, it
// indicates `ACCEPT', if negative, -d_action represents the number of the
// rule to reduce to.

// `lookup()' tries to find d_token__ in the current SR array. If it fails, and
// there is no default reduction UNEXPECTED_TOKEN__ is thrown, which is then
// caught by the error-recovery function.

// The error-recovery function will pop elements off the stack until a state
// having bit flag ERR_ITEM is found. This state has a transition on _error_
// which is applied. In this _error_ state, while the current token is not a
// proper continuation, new tokens are obtained by nextToken(). If such a
// token is found, error recovery is successful and the token is
// handled according to the error state's SR table and parsing continues.
// During error recovery semantic actions are ignored.

// A state flagged with the DEF_RED flag will perform a default
// reduction if no other continuations are available for the current token.

// The ACCEPT STATE never shows a default reduction: when it is reached the
// parser returns ACCEPT(). During the grammar
// analysis phase a default reduction may have been defined, but it is
// removed during the state-definition phase.

// So:
//      s_x[] = 
//      {
//                  [_field_1_]         [_field_2_]
//
// First element:   {state-type,        idx of last element},
// Other elements:  {required token,    action to perform},
//                                      ( < 0: reduce, 
//                                          0: ACCEPT,
//                                        > 0: next state)
// Last element:    {set to d_token__,    action to perform}
//      }

// When the --thread-safe option is specified, all static data are defined as
// const. If --thread-safe is not provided, the state-tables are not defined
// as const, since the lookup() function below will modify them


namespace // anonymous
{
    char const author[] = "Frank B. Brokken (f.b.brokken@rug.nl)";

    enum 
    {
        STACK_EXPANSION = 5     // size to expand the state-stack with when
                                // full
    };

    enum ReservedTokens
    {
        PARSE_ACCEPT     = 0,   // `ACCEPT' TRANSITION
        _UNDETERMINED_   = -2,
        _EOF_            = -1,
        _error_          = 256
    };
    enum StateType       // modify statetype/data.cc when this enum changes
    {
        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
    };    
    struct PI__     // Production Info
    {
        size_t d_nonTerm; // identification number of this production's
                            // non-terminal 
        size_t d_size;    // number of elements in this production 
    };

    struct SR__     // Shift Reduce info, see its description above
    {
        union
        {
            int _field_1_;      // initializer, allowing initializations 
                                // of the SR s_[] arrays
            int d_type;
            int d_token;
        };
        union
        {
            int _field_2_;

            int d_lastIdx;          // if negative, the state uses SHIFT
            int d_action;           // may be negative (reduce), 
                                    // postive (shift), or 0 (accept)
            size_t d_errorState;    // used with Error states
        };
    };

    // $insert staticdata
    
// Productions Info Records:
PI__ const s_productionInfo[] = 
{
     {0, 0}, // not used: reduction values are negative
     {262, 0}, // 1: lines ->  <empty>
     {262, 2}, // 2: lines ->  line lines
     {263, 1}, // 3: line ->  sphereDef
     {263, 1}, // 4: line ->  atomDef
     {264, 5}, // 5: sphereDef (SPHERE) ->  SPHERE real real real real
     {265, 11}, // 6: atomDef (ATOM) ->  ATOM INT STRING STRING STRING INT real real real real real
     {265, 10}, // 7: atomDef (ATOM) ->  ATOM INT STRING STRING INT real real real real real
     {266, 1}, // 8: real (FLOAT) ->  FLOAT
     {266, 1}, // 9: real (INT) ->  INT
     {267, 1}, // 10: lines_$ ->  lines
};

// State info and SR__ transitions for each state.


SR__ s_0[] =
{
    { { REQ_DEF}, {  7} },             
    { {     262}, {  1} }, // lines    
    { {     263}, {  2} }, // line     
    { {     264}, {  3} }, // sphereDef
    { {     265}, {  4} }, // atomDef  
    { {     259}, {  5} }, // SPHERE   
    { {     260}, {  6} }, // ATOM     
    { {       0}, { -1} },             
};

SR__ s_1[] =
{
    { { REQ_TOKEN}, {            2} }, 
    { {     _EOF_}, { PARSE_ACCEPT} }, 
    { {         0}, {            0} }, 
};

SR__ s_2[] =
{
    { { REQ_DEF}, {  7} },             
    { {     262}, {  7} }, // lines    
    { {     263}, {  2} }, // line     
    { {     264}, {  3} }, // sphereDef
    { {     265}, {  4} }, // atomDef  
    { {     259}, {  5} }, // SPHERE   
    { {     260}, {  6} }, // ATOM     
    { {       0}, { -1} },             
};

SR__ s_3[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -3} }, 
};

SR__ s_4[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -4} }, 
};

SR__ s_5[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, {  8} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_6[] =
{
    { { REQ_TOKEN}, {  2} },       
    { {       257}, { 11} }, // INT
    { {         0}, {  0} },       
};

SR__ s_7[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -2} }, 
};

SR__ s_8[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 12} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_9[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -8} }, 
};

SR__ s_10[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -9} }, 
};

SR__ s_11[] =
{
    { { REQ_TOKEN}, {  2} },          
    { {       261}, { 13} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_12[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 14} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_13[] =
{
    { { REQ_TOKEN}, {  2} },          
    { {       261}, { 15} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_14[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 16} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_15[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       261}, { 17} }, // STRING
    { {       257}, { 18} }, // INT   
    { {         0}, {  0} },          
};

SR__ s_16[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -5} }, 
};

SR__ s_17[] =
{
    { { REQ_TOKEN}, {  2} },       
    { {       257}, { 19} }, // INT
    { {         0}, {  0} },       
};

SR__ s_18[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 20} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_19[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 21} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_20[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 22} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_21[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 23} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_22[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 24} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_23[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 25} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_24[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 26} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_25[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 27} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_26[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 28} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_27[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       266}, { 29} }, // real 
    { {       258}, {  9} }, // FLOAT
    { {       257}, { 10} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_28[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -7} }, 
};

SR__ s_29[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -6} }, 
};


// State array:
SR__ *s_state[] =
{
  s_0,  s_1,  s_2,  s_3,  s_4,  s_5,  s_6,  s_7,  s_8,  s_9,
  s_10,  s_11,  s_12,  s_13,  s_14,  s_15,  s_16,  s_17,  s_18,  s_19,
  s_20,  s_21,  s_22,  s_23,  s_24,  s_25,  s_26,  s_27,  s_28,  s_29,
};

} // anonymous namespace ends



// If the parsing function call uses arguments, then provide an overloaded
// function.  The code below doesn't rely on parameters, so no arguments are
// required.  Furthermore, parse uses a function try block to allow us to do
// ACCEPT and ABORT from anywhere, even from within members called by actions,
// simply throwing the appropriate exceptions.

ParserBase::ParserBase()
:
    d_stackIdx__(-1),
    // $insert debuginit
    d_debug__(false),
    d_nErrors__(0),
    // $insert requiredtokens
    d_requiredTokens__(0),
    d_acceptedTokens__(d_requiredTokens__),
    d_token__(_UNDETERMINED_),
    d_nextToken__(_UNDETERMINED_)
{}


void Parser::print__()
{
// $insert print
}

void ParserBase::clearin()
{
    d_token__ = d_nextToken__ = _UNDETERMINED_;
}

void ParserBase::push__(size_t state)
{
    if (static_cast<size_t>(d_stackIdx__ + 1) == d_stateStack__.size())
    {
        size_t newSize = d_stackIdx__ + STACK_EXPANSION;
        d_stateStack__.resize(newSize);
        d_valueStack__.resize(newSize);
    }
    ++d_stackIdx__;
    d_stateStack__[d_stackIdx__] = d_state__ = state;
    *(d_vsp__ = &d_valueStack__[d_stackIdx__]) = d_val__;
}

void ParserBase::popToken__()
{
    d_token__ = d_nextToken__;

    d_val__ = d_nextVal__;
    d_nextVal__ = STYPE__();

    d_nextToken__ = _UNDETERMINED_;
}
     
void ParserBase::pushToken__(int token)
{
    d_nextToken__ = d_token__;
    d_nextVal__ = d_val__;
    d_token__ = token;
}
     
void ParserBase::pop__(size_t count)
{
    if (d_stackIdx__ < static_cast<int>(count))
    {
        ABORT();
    }

    d_stackIdx__ -= count;
    d_state__ = d_stateStack__[d_stackIdx__];
    d_vsp__ = &d_valueStack__[d_stackIdx__];
}

inline size_t ParserBase::top__() const
{
    return d_stateStack__[d_stackIdx__];
}

void Parser::executeAction(int production)
try
{
    if (d_token__ != _UNDETERMINED_)
        pushToken__(d_token__);     // save an already available token

                                    // save default non-nested block $$
    if (int size = s_productionInfo[production].d_size)
        d_val__ = d_vsp__[1 - size];

    switch (production)
    {
        // $insert actioncases
        
        case 5:
#line 25 "grammar"
        {
         addSphere(d_vsp__[-3], d_vsp__[-2], d_vsp__[-1], d_vsp__[0]);
         }
        break;

        case 6:
#line 33 "grammar"
        {
         addSphere(d_vsp__[-4], d_vsp__[-3], d_vsp__[-2], d_vsp__[0]);
         }
        break;

        case 7:
#line 39 "grammar"
        {
         addSphere(d_vsp__[-4], d_vsp__[-3], d_vsp__[-2], d_vsp__[0]);
         }
        break;

        case 8:
#line 46 "grammar"
        {
         d_val__ = stod(d_scanner.matched());
         }
        break;

        case 9:
#line 51 "grammar"
        {
         d_val__ = stod(d_scanner.matched());
         }
        break;

    }
}
catch (std::exception const &exc)
{
    exceptionHandler__(exc);
}

inline void ParserBase::reduce__(PI__ const &pi)
{
    d_token__ = pi.d_nonTerm;
    pop__(pi.d_size);

}

// If d_token__ is _UNDETERMINED_ then if d_nextToken__ is _UNDETERMINED_ another
// token is obtained from lex(). Then d_nextToken__ is assigned to d_token__.
void Parser::nextToken()
{
    if (d_token__ != _UNDETERMINED_)        // no need for a token: got one
        return;                             // already

    if (d_nextToken__ != _UNDETERMINED_)
    {
        popToken__();                       // consume pending token
    }
    else
    {
        ++d_acceptedTokens__;               // accept another token (see
                                            // errorRecover())
        d_token__ = lex();
        if (d_token__ <= 0)
            d_token__ = _EOF_;
    }
    print();
}

// if the final transition is negative, then we should reduce by the rule
// given by its positive value. Note that the `recovery' parameter is only
// used with the --debug option
int Parser::lookup(bool recovery)
{
    // $insert threading
    SR__ *sr = s_state[d_state__];        // get the appropriate state-table
    int lastIdx = sr->d_lastIdx;        // sentinel-index in the SR__ array

    SR__ *lastElementPtr = sr + lastIdx;
    SR__ *elementPtr = sr + 1;            // start the search at s_xx[1]

    lastElementPtr->d_token = d_token__;// set search-token

    while (elementPtr->d_token != d_token__)
        ++elementPtr;

    if (elementPtr == lastElementPtr)   // reached the last element
    {
        if (elementPtr->d_action < 0)   // default reduction
        {
            return elementPtr->d_action;                
        }

        // No default reduction, so token not found, so error.
        throw UNEXPECTED_TOKEN__;
    }

    // not at the last element: inspect the nature of the action
    // (< 0: reduce, 0: ACCEPT, > 0: shift)

    int action = elementPtr->d_action;


    return action;
}

    // When an error has occurred, pop elements off the stack until the top
    // state has an error-item. If none is found, the default recovery
    // mode (which is to abort) is activated. 
    //
    // If EOF is encountered without being appropriate for the current state,
    // then the error recovery will fall back to the default recovery mode.
    // (i.e., parsing terminates)
void Parser::errorRecovery()
try
{
    if (d_acceptedTokens__ >= d_requiredTokens__)// only generate an error-
    {                                           // message if enough tokens 
        ++d_nErrors__;                          // were accepted. Otherwise
        error("Syntax error");                  // simply skip input

    }


    // get the error state
    while (not (s_state[top__()][0].d_type & ERR_ITEM))
    {
        pop__();
    }

    // In the error state, lookup a token allowing us to proceed.
    // Continuation may be possible following multiple reductions,
    // but eventuall a shift will be used, requiring the retrieval of
    // a terminal token. If a retrieved token doesn't match, the catch below 
    // will ensure the next token is requested in the while(true) block
    // implemented below:

    int lastToken = d_token__;                  // give the unexpected token a
                                                // chance to be processed
                                                // again.

    pushToken__(_error_);                       // specify _error_ as next token
    push__(lookup(true));                       // push the error state

    d_token__ = lastToken;                      // reactivate the unexpected
                                                // token (we're now in an
                                                // ERROR state).

    bool gotToken = true;                       // the next token is a terminal

    while (true)
    {
        try
        {
            if (s_state[d_state__]->d_type & REQ_TOKEN)
            {
                gotToken = d_token__ == _UNDETERMINED_;
                nextToken();                    // obtain next token
            }
            
            int action = lookup(true);

            if (action > 0)                 // push a new state
            {
                push__(action);
                popToken__();

                if (gotToken)
                {

                    d_acceptedTokens__ = 0;
                    return;
                }
            }
            else if (action < 0)
            {
                // no actions executed on recovery but save an already 
                // available token:
                if (d_token__ != _UNDETERMINED_)
                    pushToken__(d_token__);
 
                                            // next token is the rule's LHS
                reduce__(s_productionInfo[-action]); 
            }
            else
                ABORT();                    // abort when accepting during
                                            // error recovery
        }
        catch (...)
        {
            if (d_token__ == _EOF_)
                ABORT();                    // saw inappropriate _EOF_
                      
            popToken__();                   // failing token now skipped
        }
    }
}
catch (ErrorRecovery__)       // This is: DEFAULT_RECOVERY_MODE
{
    ABORT();
}

    // The parsing algorithm:
    // Initially, state 0 is pushed on the stack, and d_token__ as well as
    // d_nextToken__ are initialized to _UNDETERMINED_. 
    //
    // Then, in an eternal loop:
    //
    //  1. If a state does not have REQ_TOKEN no token is assigned to
    //     d_token__. If the state has REQ_TOKEN, nextToken() is called to
    //      determine d_nextToken__ and d_token__ is set to
    //     d_nextToken__. nextToken() will not call lex() unless d_nextToken__ is 
    //     _UNDETERMINED_. 
    //
    //  2. lookup() is called: 
    //     d_token__ is stored in the final element's d_token field of the
    //     state's SR_ array. 
    //
    //  3. The current token is looked up in the state's SR_ array
    //
    //  4. Depending on the result of the lookup() function the next state is
    //     shifted on the parser's stack, a reduction by some rule is applied,
    //     or the parsing function returns ACCEPT(). When a reduction is
    //     called for, any action that may have been defined for that
    //     reduction is executed.
    //
    //  5. An error occurs if d_token__ is not found, and the state has no
    //     default reduction. Error handling was described at the top of this
    //     file.

int Parser::parse()
try 
{
    push__(0);                              // initial state
    clearin();                              // clear the tokens.

    while (true)
    {
        try
        {
            if (s_state[d_state__]->d_type & REQ_TOKEN)
                nextToken();                // obtain next token


            int action = lookup(false);     // lookup d_token__ in d_state__

            if (action > 0)                 // SHIFT: push a new state
            {
                push__(action);
                popToken__();               // token processed
            }
            else if (action < 0)            // REDUCE: execute and pop.
            {
                executeAction(-action);
                                            // next token is the rule's LHS
                reduce__(s_productionInfo[-action]); 
            }
            else 
                ACCEPT();
        }
        catch (ErrorRecovery__)
        {
            errorRecovery();
        }
    }
}
catch (Return__ retValue)
{
    return retValue;
}





// *** END *** parse.cc ***

// *** START *** Main.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Mon Feb 24 11:25:18 2014 EDT
//
// Time-stamp: <2015-10-26 15:39:30 dcj>
//
// ================================================================

//#define PRINT_LONGEST_WALK

#ifdef USE_MPI
#include <mpi.h>
#endif

#include <thread>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <limits>
#include <cstdlib>
#include <cmath>
#include <ctime>

// inlined #include "cmdline.h"

// inlined #include "Parser.h"
// inlined #include "Results.h"
// inlined #include "ResultsVolume.h"

// inlined #include "Geometry/Sphere.h"
// inlined #include "Geometry/Vector3.h"
// inlined #include "Geometry/Voxels.h"

// inlined #include "NearestSurfacePoint/PointFromDiscs.h"
// inlined #include "NearestSurfacePoint/PointFromPoints.h"
// inlined #include "NearestSurfacePoint/PointFromSphereCenters.h"
// inlined #include "NearestSurfacePoint/PointFromSpheres.h"

// inlined #include "InsideOutside/InOutPoints.h"
// inlined #include "InsideOutside/InOutSphereCenters.h"
// inlined #include "InsideOutside/InOutSpheres.h"

#if defined USE_LINEAR_SM
// inlined #include "SphereModel/Linear.h"
using SpheresModel = Linear;
#elif defined USE_CGAL_AABB_SM
// inlined #include "SphereModel/CGAL_AABB.h"
using SpheresModel = CGAL_AABB;
#elif defined USE_REGULAR_GRID_SPHERES_SM
// inlined #include "SphereModel/RegularGridSpheres.h"
using SpheresModel = RegularGridSpheres;
#elif defined USE_OCTREE_SPHERES_SM
// inlined #include "SphereModel/OctreeSpheres.h"
using SpheresModel = OctreeSpheres;
#elif defined USE_ANN_SORT_SCM
// inlined #include "SphereCenterModel/ANNSort.h"
using SpheresModel = ANNSort;
#elif defined USE_FLANN_SORT_SCM
// inlined #include "SphereCenterModel/FLANNSort.h"
using SpheresModel = FLANNSort;
#elif defined USE_NANOFLANN_SORT_SCM
// inlined #include "SphereCenterModel/NanoFLANNSort.h"
using SpheresModel = NanoFLANNSort;
#elif defined USE_CGAL_SORT_SCM
// inlined #include "SphereCenterModel/CGALSort.h"
using SpheresModel = CGALSort;
#elif defined USE_NEARPT3_SORT_SCM
// inlined #include "SphereCenterModel/Nearpt3Sort.h"
using SpheresModel = Nearpt3Sort;
#elif defined USE_OCTREE_SORT_SCM
// inlined #include "SphereCenterModel/OctreeSort.h"
using SpheresModel = OctreeSort;
#elif defined USE_NANOFLANN_SAMPLE_PM
// inlined #include "PointModel/NanoFLANNSample.h"
using SpheresModel = NanoFLANNSample;
#  if !defined USE_EXTERIOR_PROBLEM_SURFACE
#  error "NanoFLANNSample cannot be used without Exterior Problem Surface"
#  endif
#elif defined USE_NANOFLANN_SURFACE_SAMPLE_PM
// inlined #include "PointModel/NanoFLANNSurfaceSample.h"
using SpheresModel = NanoFLANNSurfaceSample;
#else
#error "No SpheresModel class selected"
#endif

#if defined USE_SPHERES_MODEL
using SpheresNearestSurfacePointFinder = PointFromSpheres<SpheresModel>;
using SpheresInsideOutsideTester       = InOutSpheres<SpheresModel>;
#elif defined USE_SPHERE_CENTERS_MODEL
using SpheresNearestSurfacePointFinder = PointFromSphereCenters<SpheresModel>;
using SpheresInsideOutsideTester       = InOutSphereCenters<SpheresModel>;
#elif defined USE_POINT_SAMPLED_MODEL
using SpheresNearestSurfacePointFinder = PointFromPoints<SpheresModel>;
using SpheresInsideOutsideTester       = InOutPoints<SpheresModel>;
#endif

// inlined #include "DiscModel/NanoFLANNDisc.h"
using VoxelsModel = NanoFLANNDisc;

using VoxelsNearestSurfacePointFinder = PointFromDiscs<VoxelsModel>;

using VoxelsInsideOutsideTester = InOutPoints<VoxelsModel>;

#if defined USE_RAND_RNG
// inlined #include "RandomNumber/Rand.h"
using RandomNumberGenerator = Rand;
#elif defined USE_SPRNG_RNG
// inlined #include "RandomNumber/SPRNG.h"
using RandomNumberGenerator = SPRNG;
#else
#error "No RandomNumber class selected"
#endif

// inlined #include "BoundingSphere/BoundingSphereAABB.h"

// inlined #include "SpherePoint/RandomSpherePointMarsaglia.h"
// inlined #include "SpherePoint/RandomSpherePointPolar.h"
// inlined #include "SpherePoint/BiasedSpherePointRejection.h"
// inlined #include "SpherePoint/BiasedSpherePointDirect.h"
// inlined #include "SpherePoint/RandomBallPointRejection.h"

// inlined #include "Walker/WalkerExterior.h"
// inlined #include "Walker/SamplerInterior.h"

// inlined #include "MemMonitor.h"
// inlined #include "Timer.h"

// ================================================================

using BoundingSphereGenerator = 
  BoundingSphereAABB<double>;

using RandomSpherePointGenerator = 
  RandomSpherePointMarsaglia<double, 
			     RandomNumberGenerator>;

using BiasedSpherePointGenerator = 
  BiasedSpherePointDirect<double, 
			  RandomNumberGenerator, 
			  RandomSpherePointGenerator>;

using RandomBallPointGenerator =
  RandomBallPointRejection<double,
			   RandomNumberGenerator>;

// ================================================================

void
parseInputFile(char const * fileName, 
	       std::vector<Sphere<double> > * spheres);

void
mpiSendSpheres(std::vector<Sphere<double> > const * spheres);

void
mpiReceiveSpheres(std::vector<Sphere<double> > * spheres);

void
getOptions(int argc, char **argv, 
	   char * & fileName, 
	   int & inputPrimitive,
	   int & numThreads,
	   int & seed,
	   double & fracErrorBound, 
	   double & shellThickness,
	   int & totalNumWalks,
	   int & totalNumSamples,
	   char * & surfacePointsFileName,
	   double & initializeTime,
	   bool & printCounts,
	   bool & printBenchmarks);

void
getSpheres(int mpiRank,
	   char const * fileName,
	   std::vector<Sphere<double> > * spheres,
	   double & readTime,
	   double & broadcastTime);

template <class NearestSurfacePointFinder>
void
doWalkOnSpheres(int numThreads,
		int numWalksPerProcess,
		Sphere<double> const * boundingSphere, 
		NearestSurfacePointFinder const * 
		nearestSurfacePointFinder,
		RandomNumberGenerator * const * threadRNGs,
		double fracErrorBound,
		double shellThickness,
		Results<RandomNumberGenerator> & results,
		double & walkTime, bool cmdline, US_Udp_Msg  * zeno_us_udp_msg);

template <class NearestSurfacePointFinder>
void
doWalkOnSpheresThread(Sphere<double> const * boundingSphere, 
		      NearestSurfacePointFinder const * 
		      nearestSurfacePointFinder,
		      RandomNumberGenerator * const * randomNumberGenerators,
		      int threadNum,
		      double fracErrorBound,
		      double shellThickness,
		      int numWalks,
		      Results<RandomNumberGenerator> * results,
                      std::promise<bool> * p0, bool cmdline, US_Udp_Msg  * zeno_us_udp_msg
                      );

template <class InsideOutsideTester>
void
doInteriorSampling(int numThreads,
		   int numSamplesPerProcess,
		   Sphere<double> const * boundingSphere, 
		   InsideOutsideTester const * insideOutsideTester,
		   RandomNumberGenerator * const * threadRNGs,
		   double fracErrorBound,
		   ResultsVolume & resultsVolume,
		   double & sampleTime);

template <class InsideOutsideTester>
void
doInteriorSamplingThread(Sphere<double> const * boundingSphere, 
			 InsideOutsideTester const * insideOutsideTester,
			 RandomNumberGenerator * const * randomNumberGenerators,
			 int threadNum,
			 double fracErrorBound,
			 int numSamples,
			 ResultsVolume * resultsVolume);

void
mpiReduceTime(double & time);

void
printOutput(int mpiRank,
	    bool printCounts,
	    bool printBenchmarks,
	    double shellThickness,
	    Sphere<double> const * boundingSphere,
	    ResultsVolume const * resultsVolume,
	    Results<RandomNumberGenerator> const * results,
	    char const * surfacePointsFileName, 
	    double initializeTime,
	    double readTime,
	    double broadcastTime,
	    double preprocessTime,
	    double walkTime,
	    double reduceTime,
	    double surfacePreprocessTime,
	    double sampleTime,
	    double volumeReduceTime);

void
printTime(char const * label, int mpiRank);

void
sampleRAM(char const * label, bool print, 
	  MemMonitor * memMonitor, int mpiRank);

void
writePoints(char const * fileName, 
	    std::vector<Vector3<double> > const * points,
	    std::vector<Vector3<char> > const * charges);

// ================================================================

enum {SPHERE_PRIMITIVES, VOXEL_PRIMITIVES};

// ================================================================

int zeno_cxx_main(int argc, char **argv, const char * fname, bool cmdline_temp, US_Udp_Msg  * zeno_us_udp_msg) { zeno_cxx_fout = new zeno_fout( fname );

  bool cmdline = cmdline_temp;

  const double defaultShellThicknessFactor = 0.000001;

  char * fileName              = NULL;
  int inputPrimitive           = 0;
  int numThreads               = 0;
  int seed                     = 0;
  double fracErrorBound        = 0;
  double shellThickness        = 0;
  int totalNumWalks            = 0;
  int totalNumSamples          = 0;
  char * surfacePointsFileName = NULL;
  bool printCounts             = false;
  bool printBenchmarks         = false;

  double initializeTime = 0;

  int mpiSize = 1, mpiRank = 0;

#ifdef USE_MPI
  MPI_Init(&argc, &argv);

  MPI_Comm_size(MPI_COMM_WORLD, &mpiSize);
  MPI_Comm_rank(MPI_COMM_WORLD, &mpiRank);
#endif

  getOptions(argc, argv, 
	     fileName, 
	     inputPrimitive,
	     numThreads,
	     seed,
	     fracErrorBound, 
	     shellThickness, 
	     totalNumWalks,
	     totalNumSamples,
	     surfacePointsFileName,
	     initializeTime,
	     printCounts,
	     printBenchmarks);

  
  cout << QString("PARAMS: cmdline: %1").arg(cmdline) << endl;
  cout << QString("PARAMS: filename: %1").arg(fileName) << endl;
  cout << QString("PARAMS: inputPrimitive: %1").arg(inputPrimitive)<< endl; 
  cout << QString("PARAMS: numThreads:  %1").arg(numThreads)<< endl;
  cout << QString("PARAMS: seed:  %1").arg(seed)<< endl;
  cout << QString("PARAMS: fracErrorBound: %1").arg(fracErrorBound)<< endl; 
  cout << QString("PARAMS: shellThickness: %1").arg(shellThickness)<< endl;
  cout << QString("PARAMS: totalNumWalks: %1").arg(totalNumWalks)<< endl;
  cout << QString("PARAMS: totalNumSamples: %1").arg(totalNumSamples)<< endl;
  cout << QString("PARAMS: surfacePointsFileName: %1").arg(surfacePointsFileName)<< endl;
  cout << QString("PARAMS: initializeTime: %1").arg(initializeTime)<< endl;
  cout << QString("PARAMS: printCounts: %1").arg(printCounts)<< endl;
  cout << QString("PARAMS: printBenchmarks: %1").arg(printBenchmarks)<< endl;
  cout << QString("PARAMS: SPHERE_PRIMITIVES: %1").arg(SPHERE_PRIMITIVES)<< endl;
  cout << QString("PARAMS: VOXEL_PRIMITIVES: %1").arg(VOXEL_PRIMITIVES)<< endl;
  
  
  MemMonitor * memMonitor = new MemMonitor;

  int numWalksPerProcess = totalNumWalks / mpiSize;

  if (mpiRank < totalNumWalks % mpiSize) {
    numWalksPerProcess ++;
  }

  int numSamplesPerProcess = totalNumSamples / mpiSize;

  if (mpiRank < totalNumSamples % mpiSize) {
    numSamplesPerProcess ++;
  }

  printTime("Start time:\n", mpiRank);

  sampleRAM("RAM after initialization", printBenchmarks,
	    memMonitor, mpiRank);

  double readTime      = 0;
  double broadcastTime = 0;

  std::vector<Sphere<double> > spheres;

  SpheresModel spheresModel;

  SpheresNearestSurfacePointFinder * spheresNearestSurfacePointFinder = NULL;

  Voxels<double> voxels;

  VoxelsModel voxelsModel;

  VoxelsNearestSurfacePointFinder * voxelsNearestSurfacePointFinder   = NULL;

  Sphere<double> boundingSphere;

  Timer preprocessTimer;

  if (inputPrimitive == SPHERE_PRIMITIVES) {
    getSpheres(mpiRank,
	       fileName,
	       &spheres,
	       readTime,
	       broadcastTime);

    preprocessTimer.start();

    boundingSphere = BoundingSphereGenerator::generate(&spheres);

    if (shellThickness < 0) {
      shellThickness = boundingSphere.getRadius() * defaultShellThicknessFactor;
    }

    spheresModel.preprocess(&spheres, fracErrorBound);

    spheresNearestSurfacePointFinder = 
      new SpheresNearestSurfacePointFinder(&spheresModel);
  }
  else if (inputPrimitive == VOXEL_PRIMITIVES) {
    bool voxelsLoaded = voxels.loadFitsGz(fileName);

    if (!voxelsLoaded) {
      zeno_cxx_fout->ofs << "Error loading voxel file " << fileName << std::endl;
      return 1;
    }

    boundingSphere = BoundingSphereGenerator::generate(&voxels);

    if (shellThickness < 0) {
      shellThickness = boundingSphere.getRadius() * defaultShellThicknessFactor;
    }

    voxels.sampleSurface();

    voxelsModel.preprocess(voxels.getPoints(), 
			   voxels.getNormals(),
			   voxels.getDiscRadius(),
			   fracErrorBound);

    voxelsNearestSurfacePointFinder =
      new VoxelsNearestSurfacePointFinder(&voxelsModel);
  }
  else {
    assert(0);
  }

  sampleRAM("RAM after loading input data", printBenchmarks,
	    memMonitor, mpiRank);

  //us_qdebug("Insidezeno1");

  //one stream for each thread plus one for the results
  int numStreams = numThreads * mpiSize + 1;

  RandomNumberGenerator resultsRNG(numStreams - 1, numStreams, seed);

  bool saveHitPoints = (surfacePointsFileName != NULL);

  Results<RandomNumberGenerator> results(&resultsRNG,
					 &boundingSphere,
                                         numThreads,
                                         saveHitPoints);

  ResultsVolume resultsVolume(numThreads);

  sampleRAM("RAM after building spatial data structure", printBenchmarks,
	    memMonitor, mpiRank);

  //us_qdebug("Insidezeno2");

  RandomNumberGenerator * * threadRNGs = 
    new RandomNumberGenerator *[numThreads];

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    int streamNum = mpiRank * numThreads + threadNum;

    threadRNGs[threadNum] = 
      new RandomNumberGenerator(streamNum, numStreams, seed);
  }

  preprocessTimer.stop();
  double preprocessTime = preprocessTimer.getTime();

  double walkTime = 0;

  //us_qdebug("Insidezeno21");
  
  if (inputPrimitive == SPHERE_PRIMITIVES) {
    //us_qdebug("Insidezeno211a");
    doWalkOnSpheres(numThreads,
		    numWalksPerProcess,
		    &boundingSphere, 
		    spheresNearestSurfacePointFinder,
		    threadRNGs,
		    fracErrorBound,
		    shellThickness,
		    results,
		    walkTime,
		    cmdline,
		    zeno_us_udp_msg
		    );

    //us_qdebug("Insidezeno211b");
  }
  else if (inputPrimitive == VOXEL_PRIMITIVES) {
    //us_qdebug("Insidezeno221a");
    doWalkOnSpheres(numThreads,
		    numWalksPerProcess,
		    &boundingSphere, 
		    voxelsNearestSurfacePointFinder,
		    threadRNGs,
		    fracErrorBound,
		    shellThickness,
		    results,
		    walkTime, 
		    cmdline,
		    zeno_us_udp_msg
		    );
    
    //us_qdebug("Insidezeno222a");
  }
  else {
    assert(0);
  }

  sampleRAM("RAM after walk on spheres", printBenchmarks,
	    memMonitor, mpiRank);

  Timer reduceTimer;
  reduceTimer.start();

  //us_qdebug("Insidezeno3");

#ifdef PRINT_LONGEST_WALK
  mpiReduceTime(walkTime);
#endif

  results.reduce();

  reduceTimer.stop();
  double reduceTime = reduceTimer.getTime();

  Timer surfacePreprocessTimer;
  surfacePreprocessTimer.start();

  SpheresInsideOutsideTester * spheresInsideOutsideTester = NULL;
  VoxelsInsideOutsideTester * voxelsInsideOutsideTester   = NULL;

  if (inputPrimitive == SPHERE_PRIMITIVES) {
    spheresInsideOutsideTester = new SpheresInsideOutsideTester(&spheresModel);
  }
  else if (inputPrimitive == VOXEL_PRIMITIVES) {
    voxelsInsideOutsideTester = new VoxelsInsideOutsideTester(&voxelsModel);
  }
  else {
    assert(0);
  }

  surfacePreprocessTimer.stop();
  double surfacePreprocessTime = preprocessTimer.getTime();

  double sampleTime = 0;

  if (inputPrimitive == SPHERE_PRIMITIVES) {
    doInteriorSampling(numThreads,
		       numSamplesPerProcess,
		       &boundingSphere, 
		       spheresInsideOutsideTester,
		       threadRNGs,
		       fracErrorBound,
		       resultsVolume,
		       sampleTime);
  }
  else if (inputPrimitive == VOXEL_PRIMITIVES) {
    doInteriorSampling(numThreads,
		       numSamplesPerProcess,
		       &boundingSphere, 
		       voxelsInsideOutsideTester,
		       threadRNGs,
		       fracErrorBound,
		       resultsVolume,
		       sampleTime);
  }
  else {
    assert(0);
  }

  sampleRAM("RAM after interior samples", printBenchmarks,
	    memMonitor, mpiRank);

  Timer volumeReduceTimer;
  volumeReduceTimer.start();

  resultsVolume.reduce();

  volumeReduceTimer.stop();
  double volumeReduceTime = volumeReduceTimer.getTime();

  printOutput(mpiRank,
	      printCounts,
	      printBenchmarks,
	      shellThickness,
	      &boundingSphere,
	      &resultsVolume,
	      &results,
	      surfacePointsFileName,
	      initializeTime,
	      readTime,
	      broadcastTime,
	      preprocessTime,
	      walkTime,
	      reduceTime,
	      surfacePreprocessTime,
	      sampleTime,
	      volumeReduceTime);

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    delete threadRNGs[threadNum];
  }

  delete spheresNearestSurfacePointFinder;
  delete voxelsNearestSurfacePointFinder;

  delete spheresInsideOutsideTester;
  delete voxelsInsideOutsideTester;

  delete [] threadRNGs;

  delete memMonitor;

  printTime("End time:\n", mpiRank);

#ifdef USE_MPI
  MPI_Finalize();
#endif

  return 0;
}

void
parseInputFile(char const * fileName, 
	       std::vector<Sphere<double> > * spheres) {

  std::ifstream inputFile;

  inputFile.open(fileName, std::ifstream::in);

  if (!inputFile.is_open()) {
    zeno_cxx_fout->ofs << "Error opening input file " << fileName << std::endl;
    exit(1);
  }

  Parser parser(inputFile, spheres);

  parser.parse();

  inputFile.close();
}

void
mpiSendSpheres(std::vector<Sphere<double> > const * spheres) {
#ifdef USE_MPI
  int numSpheres = spheres->size();

  MPI_Bcast(&numSpheres, 1, MPI_INT, 0, MPI_COMM_WORLD);

  double * sphereArray = new double[numSpheres*4];

  for (int i = 0; i < numSpheres; i++) {
    sphereArray[i*4 + 0] = spheres->at(i).getCenter().get(0);
    sphereArray[i*4 + 1] = spheres->at(i).getCenter().get(1);
    sphereArray[i*4 + 2] = spheres->at(i).getCenter().get(2);
    sphereArray[i*4 + 3] = spheres->at(i).getRadius();
  }

  MPI_Bcast(sphereArray, numSpheres*4, MPI_DOUBLE, 0, MPI_COMM_WORLD);

  delete [] sphereArray;
#endif
}

void
mpiReceiveSpheres(std::vector<Sphere<double> > * spheres) {
#ifdef USE_MPI
  int numSpheres = 0;

  MPI_Bcast(&numSpheres, 1, MPI_INT, 0, MPI_COMM_WORLD);

  double * sphereArray = new double[numSpheres * 4];

  MPI_Bcast(sphereArray, numSpheres*4, MPI_DOUBLE, 0, MPI_COMM_WORLD);

  for (int i = 0; i < numSpheres; i++) {
    spheres->push_back(Sphere<double>(Vector3<double>(sphereArray[i*4 + 0],
						      sphereArray[i*4 + 1],
						      sphereArray[i*4 + 2]),
				      sphereArray[i*4 + 3]));
  }

  delete [] sphereArray;
#endif
}

void
getOptions(int argc, char **argv, 
	   char * & fileName, 
	   int & inputPrimitive,
	   int & numThreads,
	   int & seed,
	   double & fracErrorBound, 
	   double & shellThickness,
	   int & totalNumWalks,
	   int & totalNumSamples,
	   char * & surfacePointsFileName,
	   double & initializeTime,
	   bool & printCounts,
	   bool & printBenchmarks) {

  Timer initializeTimer;
  initializeTimer.start();

  struct gengetopt_args_info args_info;
  struct cmdline_parser_params *params;

  params = cmdline_parser_params_create();

  params->initialize = 1;
  params->check_required = 1;

  if (cmdline_parser_ext(argc, argv, &args_info, params) != 0) {
    cmdline_parser_free(&args_info);
    free(params);
    exit(1);
  }

  fileName       = args_info.input_file_arg;
  totalNumWalks  = args_info.num_walks_arg;
  numThreads     = args_info.num_threads_arg;
  seed           = args_info.seed_arg;
  fracErrorBound = args_info.frac_error_bound_arg;

  switch(args_info.input_primitive_arg) {
  case input_primitive_arg_sphere:
    inputPrimitive = SPHERE_PRIMITIVES;
    break;
  case input_primitive_arg_voxel:
    inputPrimitive = VOXEL_PRIMITIVES;
    break;
  default:
    assert(0);
  }

  if (args_info.num_interior_samples_given) {
    totalNumSamples = args_info.num_interior_samples_arg;
  }
  else {
    totalNumSamples = -1;
  }

  if (args_info.shell_thickness_given) {
    shellThickness = args_info.shell_thickness_arg;
  }
  else {
    shellThickness = -1;
  }

  if (args_info.surface_points_file_given) {
    surfacePointsFileName = args_info.surface_points_file_arg;
  }
  else {
    surfacePointsFileName = NULL;
  }

  printCounts     = args_info.print_counts_given;
  printBenchmarks = args_info.print_benchmarks_given;

  free(params);
  //us_qdebug("Freeing memory");

  if (totalNumSamples == -1) {
    totalNumSamples = totalNumWalks;
  }

  initializeTimer.stop();
  initializeTime = initializeTimer.getTime();
}


void
getSpheres(int mpiRank,
	   char const * fileName,
	   std::vector<Sphere<double> > * spheres,
	   double & readTime,
	   double & broadcastTime) {

  Timer readTimer;
  Timer broadcastTimer;

  if (mpiRank == 0) {
    readTimer.start();
    parseInputFile(fileName, spheres);
    readTimer.stop();

    broadcastTimer.start();
    mpiSendSpheres(spheres);
    broadcastTimer.stop();
  }
  else {
    broadcastTimer.start();
    mpiReceiveSpheres(spheres);
    broadcastTimer.stop();
  }

  readTime      = readTimer.getTime();
  broadcastTime = broadcastTimer.getTime();
}

template <class NearestSurfacePointFinder>
void
doWalkOnSpheres(int numThreads,
		int numWalksPerProcess,
		Sphere<double> const * boundingSphere, 
		NearestSurfacePointFinder const * 
		nearestSurfacePointFinder,
		RandomNumberGenerator * const * threadRNGs,
		double fracErrorBound,
		double shellThickness,
		Results<RandomNumberGenerator> & results,
		double & walkTime, bool cmdline, US_Udp_Msg  * zeno_us_udp_msg) {

  Timer walkTimer;
  walkTimer.start();

  std::thread * * threads = new std::thread *[numThreads];
  std::promise < bool > p0;
  auto future = p0.get_future();

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {

    int numWalksPerThread = numWalksPerProcess / numThreads;

    if (threadNum < numWalksPerProcess % numThreads) {
      numWalksPerThread ++;
    }

    //us_qdebug("Inside_doWalkonSpheres1");
    
    threads[threadNum] = 
      new std::thread(doWalkOnSpheresThread<NearestSurfacePointFinder>,
		      boundingSphere, 
		      nearestSurfacePointFinder,
		      threadRNGs,
		      threadNum,
		      fracErrorBound,
		      shellThickness,
		      numWalksPerThread,
		      &results,
                      &p0,
		      cmdline,
		      zeno_us_udp_msg
		      );
  }

  //us_qdebug("Inside_doWalkonSpheres2");
  
  {
     bool join_now = false;
     do {
       //us_qdebug("Inside_doWalkonSpheres21");
        auto status = future.wait_for(std::chrono::milliseconds(200));
        //us_qdebug("Inside_doWalkonSpheres22");

	if(!cmdline)
	  {
	    qApp->processEvents();
	  }
	
	//us_qdebug("Inside_doWalkonSpheres23");
        if (status == std::future_status::ready) {
           join_now = true;
        }
     } while (!join_now );
  } 
  

  //us_qdebug("Inside_doWalkonSpheres3");

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    //us_qdebug("Inside_doWalkonSpheres31");
    threads[threadNum]->join();
    //us_qdebug("Inside_doWalkonSpheres32");
  }

  //us_qdebug("Inside_doWalkonSpheres4");
  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    delete threads[threadNum];
  }

  //us_qdebug("Inside_doWalkonSpheres5");
  delete [] threads;

  walkTimer.stop();
  walkTime = walkTimer.getTime();
  //us_qdebug("Inside_doWalkonSpheres6");
}

template <class NearestSurfacePointFinder>
void
doWalkOnSpheresThread(Sphere<double> const * boundingSphere, 
		      NearestSurfacePointFinder const * 
		      nearestSurfacePointFinder,
		      RandomNumberGenerator * const * randomNumberGenerators,
		      int threadNum,
		      double fracErrorBound,
		      double shellThickness,
		      int numWalks,
		      Results<RandomNumberGenerator> * results,
                      std::promise < bool > *p0, bool cmdline, US_Udp_Msg  *zeno_us_udp_msg
                      ) {

  WalkerExterior<double, 
		 RandomNumberGenerator,
		 NearestSurfacePointFinder,
		 RandomSpherePointGenerator,
		 BiasedSpherePointGenerator>
    walker(randomNumberGenerators[threadNum], 
	   boundingSphere, 
           nearestSurfacePointFinder,
           fracErrorBound,
	   shellThickness);

  //us_qdebug("WalkonSphereTHREAD");

  for (int walkNum = 0; walkNum < numWalks; walkNum++) {

    //us_qdebug(QString("Walk number_1: %1").arg(walkNum));
    
    if(!cmdline)
      {
	if ( *zeno_stop_flag ){
	  break;
	}
	
      }
	//us_qdebug(QString("Walk number_2: %1").arg(walkNum));
	
	if ( !threadNum && !( walkNum % 10000 ) ) {
	  if (!cmdline){
#if QT_VERSION < 0x040000
             // need to fix how this is done
	    zeno_progress->setValue( walkNum ); zeno_progress->setMaximum( numWalks );
#endif
	  }
	  else {
	    if ( zeno_us_udp_msg )
	      {
		map < QString, QString > msging;
		msging[ "progress_output" ] = QString("Hydro (Zeno) calculation: %1\%").arg(QString::number( int((double(walkNum)/double(numWalks))*100.0) ) ).arg(100); // arg(ppos).arg(mppos);
		msging[ "progress1" ] = QString::number(double(walkNum)/double(numWalks));
		
		zeno_us_udp_msg->send_json( msging );
		//sleep(1);
	      }   
	    
	  }
	}
     //us_qdebug(QString("Walk number_3: %1").arg(walkNum));

    bool hitObject = false;
    int numSteps   = 0;

    Vector3<double> startPoint;
    Vector3<double> endPoint;
    Vector3<double> normal;

    
    walker.walk(hitObject, numSteps,
		startPoint, endPoint, normal);

    if (hitObject) {
      results->recordHit(threadNum, &startPoint, &endPoint, &normal);
    }
    else {
      results->recordMiss(threadNum);
    }
  }

  

  if ( !threadNum ) {
     p0->set_value( true );
  }
}

template <class InsideOutsideTester>
void
doInteriorSampling(int numThreads,
		   int numSamplesPerProcess,
		   Sphere<double> const * boundingSphere, 
		   InsideOutsideTester const * insideOutsideTester,
		   RandomNumberGenerator * const * threadRNGs,
		   double fracErrorBound,
		   ResultsVolume & resultsVolume,
		   double & sampleTime) {

  Timer sampleTimer;
  sampleTimer.start();

  std::thread * * threads = new std::thread *[numThreads];

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {

    int numSamplesPerThread = numSamplesPerProcess / numThreads;

    if (threadNum < numSamplesPerProcess % numThreads) {
      numSamplesPerThread ++;
    }

    threads[threadNum] = 
      new std::thread(doInteriorSamplingThread<InsideOutsideTester>,
		      boundingSphere, 
		      insideOutsideTester,
		      threadRNGs,
		      threadNum,
		      fracErrorBound,
		      numSamplesPerThread,
		      &resultsVolume);
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    threads[threadNum]->join();
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    delete threads[threadNum];
  }

  delete [] threads;

  sampleTimer.stop();
  sampleTime = sampleTimer.getTime();
}

template <class InsideOutsideTester>
void
doInteriorSamplingThread(Sphere<double> const * boundingSphere, 
			 InsideOutsideTester const * insideOutsideTester,
			 RandomNumberGenerator * const * randomNumberGenerators,
			 int threadNum,
			 double fracErrorBound,
			 int numSamples,
			 ResultsVolume * resultsVolume) {

  SamplerInterior<double, 
		 RandomNumberGenerator,
		 InsideOutsideTester,
		 RandomBallPointGenerator>
    sampler(randomNumberGenerators[threadNum], 
	    boundingSphere, 
	    insideOutsideTester,
	    fracErrorBound);

  for (int sampleNum = 0; sampleNum < numSamples; sampleNum++) {

    bool hitObject = false;

    sampler.sample(hitObject);

    if (hitObject) {
      resultsVolume->recordHit(threadNum);
    }
    else {
      resultsVolume->recordMiss(threadNum);
    }
  }
}

void
mpiReduceTime(double & time) {
#ifdef USE_MPI
  double sendbuf = time;
  double recvbuf = 0;

  MPI_Reduce(&sendbuf, &recvbuf, 2, MPI_DOUBLE,
	     MPI_MAX, 0, MPI_COMM_WORLD);

  time = recvbuf;
#endif
}

void
printOutput(int mpiRank,
	    bool printCounts,
	    bool printBenchmarks,
	    double shellThickness,
	    Sphere<double> const * boundingSphere,
	    ResultsVolume const * resultsVolume,
	    Results<RandomNumberGenerator> const * results,
	    char const * surfacePointsFileName, 
	    double initializeTime,
	    double readTime,
	    double broadcastTime,
	    double preprocessTime,
	    double walkTime,
	    double reduceTime,
	    double surfacePreprocessTime,
	    double sampleTime,
	    double volumeReduceTime) {

  if (mpiRank == 0) {
    zeno_cxx_fout->ofs << std::endl
	      << "Launch sphere center: " << boundingSphere->getCenter() 
	      << std::endl
	      << "Launch sphere radius: " << boundingSphere->getRadius()
	      << std::endl
	      << std::endl
	      << "Skin thickness: " << shellThickness << std::endl;

    double boundingSphereVolume = boundingSphere->getVolume();
    double volume = resultsVolume->getVolume(boundingSphereVolume);

    results->print(printCounts, volume);

    double totalTime = 
      initializeTime +
      readTime +
      broadcastTime +
      preprocessTime +
      walkTime +
      reduceTime +
      surfacePreprocessTime +
      sampleTime +
      volumeReduceTime;

    if (printBenchmarks) {
      zeno_cxx_fout->ofs << std::fixed
		<< "Initialize(s)         " << initializeTime << std::endl
		<< "Read(s)               " << readTime << std::endl
		<< "Broadcast(s)          " << broadcastTime << std::endl
		<< "Preprocess(s)         " << preprocessTime << std::endl
		<< "Exterior Walk(s)      " << walkTime << std::endl
		<< "Reduce(s)             " << reduceTime << std::endl
		<< "Surface Preprocess(s) " << surfacePreprocessTime 
		<< std::endl
		<< "Volume Sample(s)      " << sampleTime << std::endl
		<< "Volume Reduce(s)      " << volumeReduceTime << std::endl
		<< "Total(s)              " << totalTime << std::endl
		<< std::endl;
    }
      
    if (surfacePointsFileName != NULL) {
      writePoints(surfacePointsFileName, 
		  results->getPoints(), 
		  results->getCharges());
    }
  }
}

void
printTime(char const * label, int mpiRank) {
  const int bufferSize = 256;

  if (mpiRank == 0) {
    time_t rawtime;
    struct tm * timeinfo;
    char buffer[bufferSize];
    
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    strftime(buffer, bufferSize, "%F %T", timeinfo);
  
    zeno_cxx_fout->ofs << label << buffer << std::endl;
  }
}

void
sampleRAM(char const * label, bool print, 
	  MemMonitor * memMonitor, int mpiRank) {

  if (mpiRank == 0) {
    memMonitor->sample();

    if (print) {
      zeno_cxx_fout->ofs << std::fixed
		<< label << " (Node " << mpiRank << "): " 
		<< memMonitor->getCurrentUsage()
		<< " MB" << std::endl;
    }
  }
}

void
writePoints(char const * fileName, 
	    std::vector<Vector3<double> > const * points,
	    std::vector<Vector3<char> > const * charges) {

  std::ofstream outputFile;

  outputFile.open(fileName, std::ofstream::out);

  if (!outputFile.is_open()) {

    zeno_cxx_fout->ofs << "Error opening output file " << fileName << std::endl;
    exit(1);
  }

  for (unsigned int i = 0; i < points->size(); i++) {

    if (charges != NULL) {
      outputFile << charges->at(i).get(0)
		 << charges->at(i).get(1)
		 << charges->at(i).get(2);
    }

    outputFile << std::setw(16) << points->at(i).get(0)
	       << std::setw(16) << points->at(i).get(1)
	       << std::setw(16) << points->at(i).get(2) << std::endl;
  }

  outputFile.close();
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Main.cc ***

// *** START *** Parser.cc ***
// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Mon Feb 24 11:24:59 2014 EDT
//
// Time-stamp: <2015-02-13 17:08:30 dcj>
//
// ================================================================

// inlined #include "Parser.h"

// ================================================================

Parser::Parser(std::istream &in, std::vector<Sphere<double> > * spheres) :
  d_scanner(in),
  spheres(spheres) {

}

void Parser::addSphere(double x, double y, double z, double r) {
  Vector3<double> center(x, y, z);

  Sphere<double> sphere(center, r);

  spheres->push_back(sphere);
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Parser.cc ***

// *** START *** MemMonitor.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Author:  Derek Juba <derek.juba@nist.gov>
// Date:    Wed May 21 17:31:03 2014 EDT
// 
// Time-stamp: <2015-04-24 10:16:12 derekj>
// 
// ================================================================

// #include <fstream>
// #include <unistd.h>

#include <sys/resource.h>

#include <cassert>

// inlined #include "MemMonitor.h"

// ================================================================

MemMonitor::MemMonitor() 
  : currentUsage(0),
    peakUsage(0) {

}

MemMonitor::~MemMonitor() {

}

// void 
// MemMonitor::sample() {
//   long int virtualMemSize = 0;
//   std::ifstream buffer("/proc/self/statm");
//   buffer >> virtualMemSize;
//   buffer.close();

//   long int pageBytes = sysconf(_SC_PAGE_SIZE);

//   currentUsage = virtualMemSize * pageBytes / (1024.f * 1024.f);

//   if (currentUsage > peakUsage) {
//     peakUsage = currentUsage;
//   }
// }

void 
MemMonitor::sample() {
  int who = RUSAGE_SELF;
  struct rusage usage;

  int error = getrusage(who, &usage);

  assert(error == 0);

  currentUsage = usage.ru_maxrss / (1000.f);

  if (currentUsage > peakUsage) {
    peakUsage = currentUsage;
  }
}

float
MemMonitor::getCurrentUsage() const {
  return currentUsage;
}

float
MemMonitor::getPeakUsage() const {
  return peakUsage;
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** MemMonitor.cc ***

// *** START *** Timer.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Author:  Derek Juba <derek.juba@nist.gov>
// Date:    Wed May 21 16:22:30 2014 EDT
// 
// Time-stamp: <2015-04-22 11:49:50 derekj>
// 
// ================================================================

// inlined #include "Timer.h"

// ================================================================

Timer::Timer() 
  : running(false),
    startTime(0),
    elapsedTime(0) {

}

Timer::~Timer() {

}

void 
Timer::start() {
  running = true;

#ifdef USE_MPI
  startTime = MPI_Wtime();
#else
  startTime = clock();
#endif
}

void 
Timer::stop() {
  running = false;

#ifdef USE_MPI
  double endTime = MPI_Wtime();
  elapsedTime += endTime - startTime;
#else
  clock_t endTime = clock();
  elapsedTime += (double)(endTime - startTime)/CLOCKS_PER_SEC;
#endif
}

void 
Timer::reset() {
  elapsedTime = 0;
}

double
Timer::getTime() const {
  if (running) {
#ifdef USE_MPI
    double endTime = MPI_Wtime();
    double currentTime = endTime - startTime;
#else
    clock_t endTime = clock();
    double currentTime = (double)(endTime - startTime)/CLOCKS_PER_SEC;
#endif

    return currentTime + elapsedTime;
  }
  else {
    return elapsedTime;
  }
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Timer.cc ***

// *** START *** ResultsVolume.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Wed Apr 22 11:11:48 2015 EDT
//
// Time-stamp: <2015-09-08 09:33:33 dcj>
//
// ================================================================

#ifdef USE_MPI
#include <mpi.h>
#endif

#include <cassert>
#include <cstdlib>

// inlined #include "ResultsVolume.h"

// ================================================================

ResultsVolume::ResultsVolume(int numThreads)
  : numThreads(numThreads),
    numHits(NULL),
    numMisses(NULL),
    reducedNumHits(0),
    reducedNumMisses(0),
    reduced(true) {

  numHits   = new int[numThreads];
  numMisses = new int[numThreads];

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    numHits[threadNum]   = 0;
    numMisses[threadNum] = 0;
  }
}

ResultsVolume::~ResultsVolume() {
  delete [] numHits;
  delete [] numMisses;
}

void 
ResultsVolume::recordHit(int threadNum) {
  assert(threadNum >= 0 && threadNum < numThreads);

  reduced = false;

  numHits[threadNum] ++;
}

void 
ResultsVolume::recordMiss(int threadNum) {
  assert(threadNum >= 0 && threadNum < numThreads);

  reduced = false;

  numMisses[threadNum] ++;
}

void 
ResultsVolume::reduce() {
  reducedNumHits   = 0;
  reducedNumMisses = 0;

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    reducedNumHits   += numHits[threadNum];
    reducedNumMisses += numMisses[threadNum];
  }

#ifdef USE_MPI
  int sendbuf[2];

  sendbuf[0] = reducedNumHits;
  sendbuf[1] = reducedNumMisses;

  int recvbuf[2];

  recvbuf[0] = 0;
  recvbuf[1] = 0;

  MPI_Reduce(sendbuf, recvbuf, 2, MPI_INT,
	     MPI_SUM, 0, MPI_COMM_WORLD);

  reducedNumHits   = recvbuf[0];
  reducedNumMisses = recvbuf[1];
#endif

  reduced = true;
}

double 
ResultsVolume::getVolume(double boundingShapeVolume) const {
  assert(reduced);

  double volume = 
    boundingShapeVolume * reducedNumHits / (reducedNumHits + reducedNumMisses);

  return volume;
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// mode: c++
// End:

// *** END *** ResultsVolume.cc ***

// *** START *** RandomNumber/Rand.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Mon Dec 29 11:44:20 2014 EDT
//
// Time-stamp: <2015-05-18 14:40:19 derekj>
//
// ================================================================

// inlined #include "Rand.h"

#include <cstdlib>

// ================================================================

Rand::Rand(int streamNum, int numStreams, int seed) {
  srand(seed);
}

Rand::~Rand() {

}

double 
Rand::getRandIn01() {
  return (rand() / (double)RAND_MAX);
}

double 
Rand::getRandInRange(double min, double max) {
  return (rand() / (double)RAND_MAX) * (max - min) + min;
}

// Local Variables:
// time-stamp-line-limit: 30
// mode: c++
// End:

// *** END *** RandomNumber/Rand.cc ***

// *** START *** SphereCenterModel/NanoFLANNSort.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Fri Aug 15 14:35:07 2014 EDT
//
// Time-stamp: <2015-08-31 17:59:53 dcj>
//
// ================================================================

#include <limits>
#include <cassert>
#include <iostream>

// inlined #include "NanoFLANNSort.h"

// ================================================================

NanoFLANNSort::NanoFLANNSort()
  : originalSpheres(NULL),
    nanoFLANNInstances() {

}

NanoFLANNSort::~NanoFLANNSort() {
  for (unsigned int i = 0; i < nanoFLANNInstances.size(); i ++) {
    delete nanoFLANNInstances.at(i).dataset;

    delete nanoFLANNInstances.at(i).kdTree;

    delete [] nanoFLANNInstances.at(i).originalSphereIndexes;
  }
}

void 
NanoFLANNSort::preprocess(std::vector<Sphere<double> > const * spheres,
			  double fracErrorBound) {

  originalSpheres = spheres;

  //count number of spheres of each radius
  for (unsigned int sphereNum = 0; 
       sphereNum < spheres->size(); 
       sphereNum ++) {

    double sphereRadiusSqr = spheres->at(sphereNum).getRadiusSqr();

    bool radiusFound = false;

    for (unsigned int radiusNum = 0; 
	 radiusNum < nanoFLANNInstances.size(); 
	 radiusNum ++) {

      if (nanoFLANNInstances.at(radiusNum).sphereRadiusSqr == sphereRadiusSqr) {
	radiusFound = true;

	nanoFLANNInstances.at(radiusNum).nPts ++;

	break;
      }
    }

    if (!radiusFound) {
      NanoFLANNInstance nanoFLANNInstance;

      nanoFLANNInstance.sphereRadiusSqr = sphereRadiusSqr;
    
      nanoFLANNInstance.nPts = 1;

      nanoFLANNInstance.dataset = NULL;
      nanoFLANNInstance.kdTree  = NULL;

      nanoFLANNInstance.originalSphereIndexes = NULL;

      nanoFLANNInstances.push_back(nanoFLANNInstance);
    }
  }

  //allocate memory for points
  for (unsigned int radiusNum = 0; 
       radiusNum < nanoFLANNInstances.size(); 
       radiusNum ++) {

    int nPts = nanoFLANNInstances.at(radiusNum).nPts;

    nanoFLANNInstances.at(radiusNum).nPts = 0; //reset point counter

    nanoFLANNInstances.at(radiusNum).originalSphereIndexes = new int[nPts];
  }

  //add spheres to instances
  for (unsigned int sphereNum = 0; 
       sphereNum < spheres->size(); 
       sphereNum ++) {

    double sphereRadiusSqr = spheres->at(sphereNum).getRadiusSqr();

    bool radiusFound = false;

    for (unsigned int radiusNum = 0; 
	 radiusNum < nanoFLANNInstances.size(); 
	 radiusNum ++) {

      if (nanoFLANNInstances.at(radiusNum).sphereRadiusSqr == sphereRadiusSqr) {
	radiusFound = true;

	int nPts = nanoFLANNInstances.at(radiusNum).nPts;

	nanoFLANNInstances.at(radiusNum).originalSphereIndexes[nPts] = 
	  sphereNum;

	nanoFLANNInstances.at(radiusNum).nPts ++;

	break;
      }
    }

    assert(radiusFound);
  }

  //build kdTrees
  for (unsigned int radiusNum = 0; 
       radiusNum < nanoFLANNInstances.size(); 
       radiusNum ++) {

    int nPts = nanoFLANNInstances.at(radiusNum).nPts;

    int * originalSphereIndexes = 
      nanoFLANNInstances.at(radiusNum).originalSphereIndexes;

    DatasetAdaptorType * dataset = 
      new DatasetAdaptorType(nPts, originalSphereIndexes, originalSpheres);

    nanoFLANNInstances.at(radiusNum).dataset = dataset;

    nanoFLANNInstances.at(radiusNum).kdTree = new KDTreeType(3, *dataset);

    nanoFLANNInstances.at(radiusNum).kdTree->buildIndex();
  }
}

void 
NanoFLANNSort::printDataStructureStats() 
  const {

  zeno_cxx_fout->ofs << "Number of NanoFLANN instances: " << nanoFLANNInstances.size()
	    << std::endl
	    << "Used memory (MB)" << std::endl;

  for (unsigned int radiusNum = 0; 
       radiusNum < nanoFLANNInstances.size(); 
       radiusNum ++) {

    zeno_cxx_fout->ofs << radiusNum << ": " 
	      << nanoFLANNInstances.at(radiusNum).kdTree->usedMemory() / 1000000.
	      << std::endl;
  }

  zeno_cxx_fout->ofs << std::endl;
}

void 
NanoFLANNSort::printSearchStats() 
  const {

}

unsigned int 
NanoFLANNSort::
getNumRadii() 
  const {

  return nanoFLANNInstances.size();
}

void 
NanoFLANNSort::
findNearestSphere(int radiusNum,
		  Vector3<double> const * queryPoint,
		  double fracErrorBound,
		  Sphere<double> const * & nearestSphere, 
		  double & centerDistSqr) 
  const {

  double query[3];

  for (int i = 0; i < 3; i++) {
    query[i] = queryPoint->get(i);
  }

  int resultIndex = -1;

  // nanoFLANNInstances.at(radiusNum).kdTree->knnSearch(query, 1, 
  // 						&resultIndex, &distSqr);

  nanoflann::SearchParams params;
  params.eps = fracErrorBound;

  nanoflann::KNNResultSet<double, int> resultSet(1);
  resultSet.init(&resultIndex, &centerDistSqr);

  nanoFLANNInstances.at(radiusNum).kdTree->findNeighbors(resultSet, query, 
						     params);

  int sphereIndex = 
    nanoFLANNInstances.at(radiusNum).originalSphereIndexes[resultIndex];

  nearestSphere = &(originalSpheres->at(sphereIndex));
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** SphereCenterModel/NanoFLANNSort.cc ***

// *** START *** DiscModel/NanoFLANNDisc.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Fri Aug 15 14:35:07 2014 EDT
//
// Time-stamp: <2015-10-19 16:21:45 dcj>
//
// ================================================================

// inlined #include "NanoFLANNDisc.h"

// ================================================================

NanoFLANNDisc::NanoFLANNDisc()
  : nanoFLANNPoint(),
    discRadius() {

}

NanoFLANNDisc::~NanoFLANNDisc() {

}

void 
NanoFLANNDisc::preprocess(std::vector<Vector3<double> > const * points,
			  std::vector<Vector3<double> > const * normals,
			  double discRadius,
			  double fracErrorBound) {

  nanoFLANNPoint.preprocess(points, 
			    normals, 
			    fracErrorBound);

  this->discRadius = discRadius;
}

void 
NanoFLANNDisc::findNearestPoint(Vector3<double> const * queryPoint,
				 double fracErrorBound,
				 Vector3<double> & nearestPoint,
				 Vector3<double> & nearestPointNormal) 
  const {

  nanoFLANNPoint.findNearestPoint(queryPoint, 
				  fracErrorBound, 
				  nearestPoint, 
				  nearestPointNormal);
}

double
NanoFLANNDisc::getDiscRadius()
  const {

  return discRadius;
}

void 
NanoFLANNDisc::printDataStructureStats() 
  const {

  nanoFLANNPoint.printDataStructureStats();
}

void 
NanoFLANNDisc::printSearchStats() 
  const {

  nanoFLANNPoint.printSearchStats();
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** DiscModel/NanoFLANNDisc.cc ***

// *** START *** cmdline.c ***
/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt --conf-parser --file-name=cmdline 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
// inlined #include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

// inlined #include "cmdline.h"

const char *gengetopt_args_info_purpose = "";

const char *gengetopt_args_info_usage = "Usage: ZenoC++ [OPTIONS]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "  -i, --input-file=STRING       Input file name",
  "      --input-primitive=ENUM    Type of input primitive  (possible\n                                  values=\"sphere\", \"voxel\"\n                                  default=`sphere')",
  "  -n, --num-walks=INT           Number of walks",
  "      --num-interior-samples=INT\n                                Number of sample points for volume computation\n                                  (default=num-walks)",
  "  -t, --num-threads=INT         Number of threads  (default=`1')",
  "      --seed=INT                Seed for the random number generator\n                                  (default=`0')",
  "      --frac-error-bound=DOUBLE Fractional error bound for nearest neighbor\n                                  search  (default=`0')",
  "      --shell-thickness=DOUBLE  Thickness of shell for absorbing walkers\n                                  (default=LaunchSphereRadius * 10^-6)",
  "      --surface-points-file=STRING\n                                Name of file into which to write the surface\n                                  points from the Exterior problem",
  "      --print-counts            Print statistics related to counts of hit\n                                  points",
  "      --print-benchmarks        Print detailed RAM and timing information",
    0
};

typedef enum {ARG_NO
  , ARG_STRING
  , ARG_INT
  , ARG_DOUBLE
  , ARG_ENUM
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);
struct line_list
{
  char * string_arg;
  struct line_list * next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void
free_cmd_list(void)
{
  /* free the list of a previous call */
  if (cmd_line_list)
    {
      while (cmd_line_list) {
        cmd_line_list_tmp = cmd_line_list;
        cmd_line_list = cmd_line_list->next;
        free (cmd_line_list_tmp->string_arg);
        free (cmd_line_list_tmp);
      }
    }
}


const char *cmdline_parser_input_primitive_values[] = {"sphere", "voxel", 0}; /*< Possible values for input-primitive. */

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->input_file_given = 0 ;
  args_info->input_primitive_given = 0 ;
  args_info->num_walks_given = 0 ;
  args_info->num_interior_samples_given = 0 ;
  args_info->num_threads_given = 0 ;
  args_info->seed_given = 0 ;
  args_info->frac_error_bound_given = 0 ;
  args_info->shell_thickness_given = 0 ;
  args_info->surface_points_file_given = 0 ;
  args_info->print_counts_given = 0 ;
  args_info->print_benchmarks_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->input_file_arg = NULL;
  args_info->input_file_orig = NULL;
  args_info->input_primitive_arg = input_primitive_arg_sphere;
  args_info->input_primitive_orig = NULL;
  args_info->num_walks_orig = NULL;
  args_info->num_interior_samples_orig = NULL;
  args_info->num_threads_arg = 1;
  args_info->num_threads_orig = NULL;
  args_info->seed_arg = 0;
  args_info->seed_orig = NULL;
  args_info->frac_error_bound_arg = 0;
  args_info->frac_error_bound_orig = NULL;
  args_info->shell_thickness_orig = NULL;
  args_info->surface_points_file_arg = NULL;
  args_info->surface_points_file_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->input_file_help = gengetopt_args_info_help[2] ;
  args_info->input_primitive_help = gengetopt_args_info_help[3] ;
  args_info->num_walks_help = gengetopt_args_info_help[4] ;
  args_info->num_interior_samples_help = gengetopt_args_info_help[5] ;
  args_info->num_threads_help = gengetopt_args_info_help[6] ;
  args_info->seed_help = gengetopt_args_info_help[7] ;
  args_info->frac_error_bound_help = gengetopt_args_info_help[8] ;
  args_info->shell_thickness_help = gengetopt_args_info_help[9] ;
  args_info->surface_points_file_help = gengetopt_args_info_help[10] ;
  args_info->print_counts_help = gengetopt_args_info_help[11] ;
  args_info->print_benchmarks_help = gengetopt_args_info_help[12] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->input_file_arg));
  free_string_field (&(args_info->input_file_orig));
  free_string_field (&(args_info->input_primitive_orig));
  free_string_field (&(args_info->num_walks_orig));
  free_string_field (&(args_info->num_interior_samples_orig));
  free_string_field (&(args_info->num_threads_orig));
  free_string_field (&(args_info->seed_orig));
  free_string_field (&(args_info->frac_error_bound_orig));
  free_string_field (&(args_info->shell_thickness_orig));
  free_string_field (&(args_info->surface_points_file_arg));
  free_string_field (&(args_info->surface_points_file_orig));
  
  

  clear_given (args_info);
}

/**
 * @param val the value to check
 * @param values the possible values
 * @return the index of the matched value:
 * -1 if no value matched,
 * -2 if more than one value has matched
 */
static int
check_possible_values(const char *val, const char *values[])
{
  int i, found, last;
  size_t len;

  if (!val)   /* otherwise strlen() crashes below */
    return -1; /* -1 means no argument for the option */

  found = last = 0;

  for (i = 0, len = strlen(val); values[i]; ++i)
    {
      if (strncmp(val, values[i], len) == 0)
        {
          ++found;
          last = i;
          if (strlen(values[i]) == len)
            return i; /* exact macth no need to check more */
        }
    }

  if (found == 1) /* one match: OK */
    return last;

  return (found ? -2 : -1); /* return many values or none matched */
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  int found = -1;
  if (arg) {
    if (values) {
      found = check_possible_values(arg, values);      
    }
    if (found >= 0)
      fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
    else
      fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->input_file_given)
    write_into_file(outfile, "input-file", args_info->input_file_orig, 0);
  if (args_info->input_primitive_given)
    write_into_file(outfile, "input-primitive", args_info->input_primitive_orig, cmdline_parser_input_primitive_values);
  if (args_info->num_walks_given)
    write_into_file(outfile, "num-walks", args_info->num_walks_orig, 0);
  if (args_info->num_interior_samples_given)
    write_into_file(outfile, "num-interior-samples", args_info->num_interior_samples_orig, 0);
  if (args_info->num_threads_given)
    write_into_file(outfile, "num-threads", args_info->num_threads_orig, 0);
  if (args_info->seed_given)
    write_into_file(outfile, "seed", args_info->seed_orig, 0);
  if (args_info->frac_error_bound_given)
    write_into_file(outfile, "frac-error-bound", args_info->frac_error_bound_orig, 0);
  if (args_info->shell_thickness_given)
    write_into_file(outfile, "shell-thickness", args_info->shell_thickness_orig, 0);
  if (args_info->surface_points_file_given)
    write_into_file(outfile, "surface-points-file", args_info->surface_points_file_orig, 0);
  if (args_info->print_counts_given)
    write_into_file(outfile, "print-counts", 0, 0 );
  if (args_info->print_benchmarks_given)
    write_into_file(outfile, "print-benchmarks", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = us_fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (! args_info->input_file_given)
    {
      fprintf (stderr, "%s: '--input-file' ('-i') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->num_walks_given)
    {
      fprintf (stderr, "%s: '--num-walks' ('-n') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  
  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  if (possible_values && (found = check_possible_values((value ? value : default_value), possible_values)) < 0)
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt, short_opt,
          (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt,
          (additional_error ? additional_error : ""));
      return 1; /* failure */
    }
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  case ARG_ENUM:
    if (val) *((int *)field) = found;
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "input-file",	1, NULL, 'i' },
        { "input-primitive",	1, NULL, 0 },
        { "num-walks",	1, NULL, 'n' },
        { "num-interior-samples",	1, NULL, 0 },
        { "num-threads",	1, NULL, 't' },
        { "seed",	1, NULL, 0 },
        { "frac-error-bound",	1, NULL, 0 },
        { "shell-thickness",	1, NULL, 0 },
        { "surface-points-file",	1, NULL, 0 },
        { "print-counts",	0, NULL, 0 },
        { "print-benchmarks",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVi:n:t:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'i':	/* Input file name.  */
        
        
          if (update_arg( (void *)&(args_info->input_file_arg), 
               &(args_info->input_file_orig), &(args_info->input_file_given),
              &(local_args_info.input_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "input-file", 'i',
              additional_error))
            goto failure;
        
          break;
        case 'n':	/* Number of walks.  */
        
        
          if (update_arg( (void *)&(args_info->num_walks_arg), 
               &(args_info->num_walks_orig), &(args_info->num_walks_given),
              &(local_args_info.num_walks_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "num-walks", 'n',
              additional_error))
            goto failure;
        
          break;
        case 't':	/* Number of threads.  */
        
        
          if (update_arg( (void *)&(args_info->num_threads_arg), 
               &(args_info->num_threads_orig), &(args_info->num_threads_given),
              &(local_args_info.num_threads_given), optarg, 0, "1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "num-threads", 't',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* Type of input primitive.  */
          if (strcmp (long_options[option_index].name, "input-primitive") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->input_primitive_arg), 
                 &(args_info->input_primitive_orig), &(args_info->input_primitive_given),
                &(local_args_info.input_primitive_given), optarg, cmdline_parser_input_primitive_values, "sphere", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "input-primitive", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of sample points for volume computation  (default=num-walks).  */
          else if (strcmp (long_options[option_index].name, "num-interior-samples") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->num_interior_samples_arg), 
                 &(args_info->num_interior_samples_orig), &(args_info->num_interior_samples_given),
                &(local_args_info.num_interior_samples_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "num-interior-samples", '-',
                additional_error))
              goto failure;
          
          }
          /* Seed for the random number generator.  */
          else if (strcmp (long_options[option_index].name, "seed") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->seed_arg), 
                 &(args_info->seed_orig), &(args_info->seed_given),
                &(local_args_info.seed_given), optarg, 0, "0", ARG_INT,
                check_ambiguity, override, 0, 0,
                "seed", '-',
                additional_error))
              goto failure;
          
          }
          /* Fractional error bound for nearest neighbor search.  */
          else if (strcmp (long_options[option_index].name, "frac-error-bound") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->frac_error_bound_arg), 
                 &(args_info->frac_error_bound_orig), &(args_info->frac_error_bound_given),
                &(local_args_info.frac_error_bound_given), optarg, 0, "0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "frac-error-bound", '-',
                additional_error))
              goto failure;
          
          }
          /* Thickness of shell for absorbing walkers  (default=LaunchSphereRadius * 10^-6).  */
          else if (strcmp (long_options[option_index].name, "shell-thickness") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->shell_thickness_arg), 
                 &(args_info->shell_thickness_orig), &(args_info->shell_thickness_given),
                &(local_args_info.shell_thickness_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "shell-thickness", '-',
                additional_error))
              goto failure;
          
          }
          /* Name of file into which to write the surface points from the Exterior problem.  */
          else if (strcmp (long_options[option_index].name, "surface-points-file") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->surface_points_file_arg), 
                 &(args_info->surface_points_file_orig), &(args_info->surface_points_file_given),
                &(local_args_info.surface_points_file_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "surface-points-file", '-',
                additional_error))
              goto failure;
          
          }
          /* Print statistics related to counts of hit points.  */
          else if (strcmp (long_options[option_index].name, "print-counts") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->print_counts_given),
                &(local_args_info.print_counts_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "print-counts", '-',
                additional_error))
              goto failure;
          
          }
          /* Print detailed RAM and timing information.  */
          else if (strcmp (long_options[option_index].name, "print-benchmarks") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->print_benchmarks_given),
                &(local_args_info.print_benchmarks_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "print-benchmarks", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}

#ifndef CONFIG_FILE_LINE_SIZE
#define CONFIG_FILE_LINE_SIZE 2048
#endif
#define ADDITIONAL_ERROR " in configuration file "

#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE+3)
/* 3 is for "--" and "=" */

static int
_cmdline_parser_configfile (const char *filename, int *my_argc)
{
  FILE* file;
  char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];
  char linebuf[CONFIG_FILE_LINE_SIZE];
  int line_num = 0;
  int result = 0, equal;
  char *fopt, *farg;
  char *str_index;
  size_t len, next_token;
  char delimiter;

  if ((file = us_fopen(filename, "r")) == 0)
    {
      fprintf (stderr, "%s: Error opening configuration file '%s'\n",
               CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != 0)
    {
      ++line_num;
      my_argv[0] = '\0';
      len = strlen(linebuf);
      if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1))
        {
          fprintf (stderr, "%s:%s:%d: Line too long in configuration file\n",
                   CMDLINE_PARSER_PACKAGE, filename, line_num);
          result = EXIT_FAILURE;
          break;
        }

      /* find first non-whitespace character in the line */
      next_token = strspn (linebuf, " \t\r\n");
      str_index  = linebuf + next_token;

      if ( str_index[0] == '\0' || str_index[0] == '#')
        continue; /* empty line or comment line is skipped */

      fopt = str_index;

      /* truncate fopt at the end of the first non-valid character */
      next_token = strcspn (fopt, " \t\r\n=");

      if (fopt[next_token] == '\0') /* the line is over */
        {
          farg  = 0;
          equal = 0;
          goto noarg;
        }

      /* remember if equal sign is present */
      equal = (fopt[next_token] == '=');
      fopt[next_token++] = '\0';

      /* advance pointers to the next token after the end of fopt */
      next_token += strspn (fopt + next_token, " \t\r\n");

      /* check for the presence of equal sign, and if so, skip it */
      if ( !equal )
        if ((equal = (fopt[next_token] == '=')))
          {
            next_token++;
            next_token += strspn (fopt + next_token, " \t\r\n");
          }
      str_index  += next_token;

      /* find argument */
      farg = str_index;
      if ( farg[0] == '\"' || farg[0] == '\'' )
        { /* quoted argument */
          str_index = strchr (++farg, str_index[0] ); /* skip opening quote */
          if (! str_index)
            {
              fprintf
                (stderr,
                 "%s:%s:%d: unterminated string in configuration file\n",
                 CMDLINE_PARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              break;
            }
        }
      else
        { /* read up the remaining part up to a delimiter */
          next_token = strcspn (farg, " \t\r\n#\'\"");
          str_index += next_token;
        }

      /* truncate farg at the delimiter and store it for further check */
      delimiter = *str_index, *str_index++ = '\0';

      /* everything but comment is illegal at the end of line */
      if (delimiter != '\0' && delimiter != '#')
        {
          str_index += strspn(str_index, " \t\r\n");
          if (*str_index != '\0' && *str_index != '#')
            {
              fprintf
                (stderr,
                 "%s:%s:%d: malformed string in configuration file\n",
                 CMDLINE_PARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              break;
            }
        }

    noarg:
      if (!strcmp(fopt,"include")) {
        if (farg && *farg) {
          result = _cmdline_parser_configfile(farg, my_argc);
        } else {
          fprintf(stderr, "%s:%s:%d: include requires a filename argument.\n",
                  CMDLINE_PARSER_PACKAGE, filename, line_num);
        }
        continue;
      }
      len = strlen(fopt);
      strcat (my_argv, len > 1 ? "--" : "-");
      strcat (my_argv, fopt);
      if (len > 1 && ((farg && *farg) || equal))
        strcat (my_argv, "=");
      if (farg && *farg)
        strcat (my_argv, farg);
      ++(*my_argc);

      cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
      cmd_line_list_tmp->next = cmd_line_list;
      cmd_line_list = cmd_line_list_tmp;
      cmd_line_list->string_arg = gengetopt_strdup(my_argv);
    } /* while */

  if (file)
    fclose(file);
  return result;
}

int
cmdline_parser_configfile (
  const char *filename,
                           struct gengetopt_args_info *args_info,
                           int override, int initialize, int check_required)
{
  struct cmdline_parser_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;
  
  return cmdline_parser_config_file (filename, args_info, &params);
}

int
cmdline_parser_config_file (const char *filename,
                           struct gengetopt_args_info *args_info,
                           struct cmdline_parser_params *params)
{
  int i, result;
  int my_argc = 1;
  char **my_argv_arg;
  char *additional_error;

  /* store the program name */
  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
  cmd_line_list_tmp->next = cmd_line_list;
  cmd_line_list = cmd_line_list_tmp;
  cmd_line_list->string_arg = gengetopt_strdup (CMDLINE_PARSER_PACKAGE);

  result = _cmdline_parser_configfile(filename, &my_argc);

  if (result != EXIT_FAILURE) {
    my_argv_arg = (char **) malloc((my_argc+1) * sizeof(char *));
    cmd_line_list_tmp = cmd_line_list;

    for (i = my_argc - 1; i >= 0; --i) {
      my_argv_arg[i] = cmd_line_list_tmp->string_arg;
      cmd_line_list_tmp = cmd_line_list_tmp->next;
    }

    my_argv_arg[my_argc] = 0;

    additional_error = (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);
    strcpy (additional_error, ADDITIONAL_ERROR);
    strcat (additional_error, filename);
    result =
      cmdline_parser_internal (my_argc, my_argv_arg, args_info,
                              params,
                              additional_error);

    free (additional_error);
    free (my_argv_arg);
  }

  free_cmd_list();
  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

// *** END *** cmdline.c ***

#endif
